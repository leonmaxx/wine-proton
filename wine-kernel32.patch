diff -purN '--exclude=*.orig' '--exclude=*.rej' a/dlls/kernel32/file.c b/dlls/kernel32/file.c
--- a/dlls/kernel32/file.c	2018-10-17 15:46:43.000000000 +0300
+++ b/dlls/kernel32/file.c	2018-10-28 14:12:54.427730582 +0200
@@ -1065,13 +1065,20 @@ BOOL WINAPI SetEndOfFile( HANDLE hFile )
     return FALSE;
 }
 
+
 /**************************************************************************
  *           SetFileCompletionNotificationModes   (KERNEL32.@)
  */
-BOOL WINAPI SetFileCompletionNotificationModes( HANDLE handle, UCHAR flags )
+BOOL WINAPI SetFileCompletionNotificationModes( HANDLE file, UCHAR flags )
 {
-    FIXME("%p %x - stub\n", handle, flags);
-    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+    FILE_IO_COMPLETION_NOTIFICATION_INFORMATION info;
+    IO_STATUS_BLOCK io;
+    NTSTATUS status;
+
+    info.Flags = flags;
+    status = NtSetInformationFile( file, &io, &info, sizeof(info), FileIoCompletionNotificationInformation );
+    if (status == STATUS_SUCCESS) return TRUE;
+    SetLastError( RtlNtStatusToDosError(status) );
     return FALSE;
 }
 
diff -purN '--exclude=*.orig' '--exclude=*.rej' a/dlls/ntdll/file.c b/dlls/ntdll/file.c
--- a/dlls/ntdll/file.c	2018-10-17 15:46:43.000000000 +0300
+++ b/dlls/ntdll/file.c	2018-10-28 14:17:12.091791497 +0200
@@ -2267,7 +2267,7 @@ NTSTATUS WINAPI NtQueryInformationFile(
         0,                                             /* FileIdFullDirectoryInformation */
         0,                                             /* FileValidDataLengthInformation */
         0,                                             /* FileShortNameInformation */
-        0,                                             /* FileIoCompletionNotificationInformation, */
+        sizeof(FILE_IO_COMPLETION_NOTIFICATION_INFORMATION), /* FileIoCompletionNotificationInformation, */
         0,                                             /* FileIoStatusBlockRangeInformation */
         0,                                             /* FileIoPriorityHintInformation */
         0,                                             /* FileSfioReserveInformation */
@@ -2543,6 +2543,22 @@ NTSTATUS WINAPI NtQueryInformationFile(
             }
         }
         break;
+    case FileIoCompletionNotificationInformation:
+        {
+            FILE_IO_COMPLETION_NOTIFICATION_INFORMATION *info = ptr;
+
+            SERVER_START_REQ( get_fd_compl_info )
+            {
+                req->handle = wine_server_obj_handle( hFile );
+                if (!(io->u.Status = wine_server_call( req )))
+                {
+                    info->Flags = (reply->flags & COMPLETION_SKIP_ON_SUCCESS) ?
+                                  FILE_SKIP_COMPLETION_PORT_ON_SUCCESS : 0;
+                }
+            }
+            SERVER_END_REQ;
+        }
+        break;
     case FileIdInformation:
         if (fd_get_file_info( fd, &st, &attr ) == -1) io->u.Status = FILE_GetNtStatus();
         else
@@ -2728,6 +2744,23 @@ NTSTATUS WINAPI NtSetInformationFile(HAN
             io->u.Status = STATUS_INVALID_PARAMETER_3;
         break;
 
+    case FileIoCompletionNotificationInformation:
+        if (len >= sizeof(FILE_IO_COMPLETION_NOTIFICATION_INFORMATION))
+        {
+            FILE_IO_COMPLETION_NOTIFICATION_INFORMATION *info = ptr;
+
+            SERVER_START_REQ( set_fd_compl_info )
+            {
+                req->handle   = wine_server_obj_handle( handle );
+                req->flags    = (info->Flags & FILE_SKIP_COMPLETION_PORT_ON_SUCCESS) ?
+                                COMPLETION_SKIP_ON_SUCCESS : 0;
+                io->u.Status  = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+        } else
+            io->u.Status = STATUS_INFO_LENGTH_MISMATCH;
+        break;
+
     case FileAllInformation:
         io->u.Status = STATUS_INVALID_INFO_CLASS;
         break;
diff -purN '--exclude=*.orig' '--exclude=*.rej' a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
--- a/dlls/ntdll/tests/file.c	2018-10-17 15:46:43.000000000 +0300
+++ b/dlls/ntdll/tests/file.c	2018-10-28 14:17:12.093791497 +0200
@@ -3055,12 +3055,11 @@ static void test_file_completion_informa
     if (!(h = create_temp_file(0))) return;
 
     status = pNtSetInformationFile(h, &io, &info, sizeof(info) - 1, FileIoCompletionNotificationInformation);
-    todo_wine
     ok(status == STATUS_INFO_LENGTH_MISMATCH || status == STATUS_INVALID_INFO_CLASS /* XP */,
        "expected STATUS_INFO_LENGTH_MISMATCH, got %08x\n", status);
     if (status == STATUS_INVALID_INFO_CLASS || status == STATUS_NOT_IMPLEMENTED)
     {
-        skip("FileIoCompletionNotificationInformation class not supported\n");
+        win_skip("FileIoCompletionNotificationInformation class not supported\n");
         CloseHandle(h);
         return;
     }
@@ -3083,6 +3082,11 @@ static void test_file_completion_informa
     CloseHandle(h);
     if (!(h = create_temp_file(FILE_FLAG_OVERLAPPED))) return;
 
+    info.Flags = ~0U;
+    status = pNtQueryInformationFile(h, &io, &info, sizeof(info), FileIoCompletionNotificationInformation);
+    ok(status == STATUS_SUCCESS, "expected STATUS_SUCCESS, got %08x\n", status);
+    ok(!(info.Flags & FILE_SKIP_COMPLETION_PORT_ON_SUCCESS), "got %08x\n", info.Flags);
+
     memset(&ov, 0, sizeof(ov));
     ov.hEvent = CreateEventA(NULL, TRUE, FALSE, NULL);
     port = CreateIoCompletionPort(h, NULL, 0xdeadbeef, 0);
@@ -3117,6 +3121,11 @@ static void test_file_completion_informa
     status = pNtSetInformationFile(h, &io, &info, sizeof(info), FileIoCompletionNotificationInformation);
     ok(status == STATUS_SUCCESS, "expected STATUS_SUCCESS, got %08x\n", status);
 
+    info.Flags = 0;
+    status = pNtQueryInformationFile(h, &io, &info, sizeof(info), FileIoCompletionNotificationInformation);
+    ok(status == STATUS_SUCCESS, "expected STATUS_SUCCESS, got %08x\n", status);
+    ok((info.Flags & FILE_SKIP_COMPLETION_PORT_ON_SUCCESS) != 0, "got %08x\n", info.Flags);
+
     for (i = 0; i < 10; i++)
     {
         SetLastError(0xdeadbeef);
@@ -3142,6 +3151,11 @@ static void test_file_completion_informa
     status = pNtSetInformationFile(h, &io, &info, sizeof(info), FileIoCompletionNotificationInformation);
     ok(status == STATUS_SUCCESS, "expected STATUS_SUCCESS, got %08x\n", status);
 
+    info.Flags = 0;
+    status = pNtQueryInformationFile(h, &io, &info, sizeof(info), FileIoCompletionNotificationInformation);
+    ok(status == STATUS_SUCCESS, "expected STATUS_SUCCESS, got %08x\n", status);
+    ok((info.Flags & FILE_SKIP_COMPLETION_PORT_ON_SUCCESS) != 0, "got %08x\n", info.Flags);
+
     for (i = 0; i < 10; i++)
     {
         SetLastError(0xdeadbeef);
diff -purN '--exclude=*.orig' '--exclude=*.rej' a/dlls/ntdll/tests/pipe.c b/dlls/ntdll/tests/pipe.c
--- a/dlls/ntdll/tests/pipe.c	2018-10-17 15:46:43.000000000 +0300
+++ b/dlls/ntdll/tests/pipe.c	2018-10-28 14:17:41.777785916 +0200
@@ -350,6 +350,75 @@ static void test_overlapped(void)
     CloseHandle(hEvent);
 }
 
+static void test_completion(void)
+{
+    static const char buf[] = "testdata";
+    FILE_IO_COMPLETION_NOTIFICATION_INFORMATION info;
+    HANDLE port, pipe, client;
+    IO_STATUS_BLOCK iosb;
+    OVERLAPPED ov, *pov;
+    IO_STATUS_BLOCK io;
+    NTSTATUS status;
+    DWORD num_bytes;
+    ULONG_PTR key;
+    DWORD dwret;
+    BOOL ret;
+
+    memset(&ov, 0, sizeof(ov));
+    ov.hEvent = CreateEventA(NULL, TRUE, FALSE, NULL);
+    ok(ov.hEvent != INVALID_HANDLE_VALUE, "CreateEvent failed, error %u\n", GetLastError());
+
+    status = create_pipe(&pipe, FILE_SHARE_READ | FILE_SHARE_WRITE, 0 /* OVERLAPPED */, 0);
+    ok(!status, "NtCreateNamedPipeFile returned %x\n", status);
+    status = listen_pipe(pipe, ov.hEvent, &iosb, FALSE);
+    ok(status == STATUS_PENDING, "NtFsControlFile returned %x\n", status);
+
+    client = CreateFileW(testpipe, GENERIC_READ | GENERIC_WRITE, 0, 0,
+                         OPEN_EXISTING, FILE_FLAG_OVERLAPPED, 0);
+    ok(client != INVALID_HANDLE_VALUE, "CreateFile failed, error %u\n", GetLastError());
+    dwret = WaitForSingleObject(ov.hEvent, 0);
+    ok(dwret == WAIT_OBJECT_0, "expected WAIT_OBJECT_0, got %u\n", dwret);
+
+    port = CreateIoCompletionPort(client, NULL, 0xdeadbeef, 0);
+    ok(port != NULL, "CreateIoCompletionPort failed, error %u\n", GetLastError());
+
+    ret = WriteFile(client, buf, sizeof(buf), &num_bytes, &ov);
+    ok(ret, "WriteFile failed, error %u\n", GetLastError());
+    ok(num_bytes == sizeof(buf), "expected sizeof(buf), got %u\n", num_bytes);
+
+    key = 0;
+    pov = NULL;
+    ret = GetQueuedCompletionStatus(port, &num_bytes, &key, &pov, 1000);
+    ok(ret, "GetQueuedCompletionStatus failed, error %u\n", GetLastError());
+    ok(key == 0xdeadbeef, "expected 0xdeadbeef, got %lx\n", key);
+    ok(pov == &ov, "expected %p, got %p\n", &ov, pov);
+
+    info.Flags = FILE_SKIP_COMPLETION_PORT_ON_SUCCESS;
+    status = pNtSetInformationFile(client, &io, &info, sizeof(info), FileIoCompletionNotificationInformation);
+    ok(status == STATUS_SUCCESS, "expected STATUS_SUCCESS, got %08x\n", status);
+
+    info.Flags = 0;
+    status = pNtQueryInformationFile(client, &io, &info, sizeof(info), FileIoCompletionNotificationInformation);
+    todo_wine
+    ok(status == STATUS_SUCCESS, "expected STATUS_SUCCESS, got %08x\n", status);
+    todo_wine
+    ok((info.Flags & FILE_SKIP_COMPLETION_PORT_ON_SUCCESS) != 0, "got %08x\n", info.Flags);
+
+    ret = WriteFile(client, buf, sizeof(buf), &num_bytes, &ov);
+    ok(ret, "WriteFile failed, error %u\n", GetLastError());
+    ok(num_bytes == sizeof(buf), "expected sizeof(buf), got %u\n", num_bytes);
+
+    pov = (void *)0xdeadbeef;
+    ret = GetQueuedCompletionStatus(port, &num_bytes, &key, &pov, 1000);
+    ok(!ret, "GetQueuedCompletionStatus succeeded\n");
+    ok(pov == NULL, "expected NULL, got %p\n", pov);
+
+    CloseHandle(ov.hEvent);
+    CloseHandle(client);
+    CloseHandle(pipe);
+    CloseHandle(port);
+}
+
 static BOOL userapc_called;
 static void CALLBACK userapc(ULONG_PTR dwParam)
 {
@@ -1934,6 +2003,9 @@ START_TEST(pipe)
     trace("starting overlapped tests\n");
     test_overlapped();
 
+    trace("starting completion tests\n");
+    test_completion();
+
     trace("starting FILE_PIPE_INFORMATION tests\n");
     test_filepipeinfo();
 
diff -purN '--exclude=*.orig' '--exclude=*.rej' a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
--- a/dlls/ws2_32/socket.c	2018-10-17 15:46:43.000000000 +0300
+++ b/dlls/ws2_32/socket.c	2018-10-28 14:17:48.924784573 +0200
@@ -642,7 +642,7 @@ static int ws_protocol_info(SOCKET s, in
 int WSAIOCTL_GetInterfaceCount(void);
 int WSAIOCTL_GetInterfaceName(int intNumber, char *intName);
 
-static void WS_AddCompletion( SOCKET sock, ULONG_PTR CompletionValue, NTSTATUS CompletionStatus, ULONG Information );
+static void WS_AddCompletion( SOCKET sock, ULONG_PTR CompletionValue, NTSTATUS CompletionStatus, ULONG Information, BOOL force );
 
 #define MAP_OPTION(opt) { WS_##opt, opt }
 
@@ -2459,7 +2459,7 @@ static NTSTATUS WS2_async_accept_recv( v
         return status;
 
     if (wsa->cvalue)
-        WS_AddCompletion( HANDLE2SOCKET(wsa->listen_socket), wsa->cvalue, iosb->u.Status, iosb->Information );
+        WS_AddCompletion( HANDLE2SOCKET(wsa->listen_socket), wsa->cvalue, iosb->u.Status, iosb->Information, TRUE );
 
     release_async_io( &wsa->io );
     return status;
@@ -3598,7 +3598,7 @@ static BOOL WINAPI WS2_ConnectEx(SOCKET
             {
                 ov->Internal = _get_sock_error(s, FD_CONNECT_BIT);
                 ov->InternalHigh = 0;
-                if (cvalue) WS_AddCompletion( s, cvalue, ov->Internal, ov->InternalHigh );
+                if (cvalue) WS_AddCompletion( s, cvalue, ov->Internal, ov->InternalHigh, FALSE );
                 if (ov->hEvent) NtSetEvent( ov->hEvent, NULL );
                 status = STATUS_PENDING;
             }
@@ -5089,7 +5089,7 @@ INT WINAPI WSAIoctl(SOCKET s, DWORD code
         overlapped->Internal = status;
         overlapped->InternalHigh = total;
         if (overlapped->hEvent) NtSetEvent( overlapped->hEvent, NULL );
-        if (cvalue) WS_AddCompletion( HANDLE2SOCKET(s), cvalue, status, total );
+        if (cvalue) WS_AddCompletion( HANDLE2SOCKET(s), cvalue, status, total, FALSE );
     }
 
     if (!status)
@@ -5484,7 +5484,7 @@ int WINAPI WSAPoll(WSAPOLLFD *wfds, ULON
 
 /* helper to send completion messages for client-only i/o operation case */
 static void WS_AddCompletion( SOCKET sock, ULONG_PTR CompletionValue, NTSTATUS CompletionStatus,
-                              ULONG Information )
+                              ULONG Information, BOOL force )
 {
     SERVER_START_REQ( add_fd_completion )
     {
@@ -5492,6 +5492,7 @@ static void WS_AddCompletion( SOCKET soc
         req->cvalue      = CompletionValue;
         req->status      = CompletionStatus;
         req->information = Information;
+        req->force       = force;
         wine_server_call( req );
     }
     SERVER_END_REQ;
@@ -5636,7 +5637,7 @@ static int WS2_sendto( SOCKET s, LPWSABU
         if (lpNumberOfBytesSent) *lpNumberOfBytesSent = n;
         if (!wsa->completion_func)
         {
-            if (cvalue) WS_AddCompletion( s, cvalue, STATUS_SUCCESS, n );
+            if (cvalue) WS_AddCompletion( s, cvalue, STATUS_SUCCESS, n, FALSE );
             if (lpOverlapped->hEvent) SetEvent( lpOverlapped->hEvent );
             HeapFree( GetProcessHeap(), 0, wsa );
         }
@@ -8053,7 +8054,7 @@ static int WS2_recv_base( SOCKET s, LPWS
             iosb->Information = n;
             if (!wsa->completion_func)
             {
-                if (cvalue) WS_AddCompletion( s, cvalue, STATUS_SUCCESS, n );
+                if (cvalue) WS_AddCompletion( s, cvalue, STATUS_SUCCESS, n, FALSE );
                 if (lpOverlapped->hEvent) SetEvent( lpOverlapped->hEvent );
                 HeapFree( GetProcessHeap(), 0, wsa );
             }
diff -purN '--exclude=*.orig' '--exclude=*.rej' a/dlls/ws2_32/tests/sock.c b/dlls/ws2_32/tests/sock.c
--- a/dlls/ws2_32/tests/sock.c	2018-10-17 15:46:43.000000000 +0300
+++ b/dlls/ws2_32/tests/sock.c	2018-10-28 14:17:48.927784572 +0200
@@ -85,6 +85,10 @@ static int   (WINAPI *pWSAEnumNameSpaceP
 static int   (WINAPI *pWSAEnumNameSpaceProvidersW)(LPDWORD,LPWSANAMESPACE_INFOW);
 static int   (WINAPI *pWSAPoll)(WSAPOLLFD *,ULONG,INT);
 
+/* Function pointers from ntdll */
+static NTSTATUS (WINAPI *pNtSetInformationFile)(HANDLE, PIO_STATUS_BLOCK, PVOID, ULONG, FILE_INFORMATION_CLASS);
+static NTSTATUS (WINAPI *pNtQueryInformationFile)(HANDLE, PIO_STATUS_BLOCK, PVOID, ULONG, FILE_INFORMATION_CLASS);
+
 /* Function pointers from iphlpapi */
 static DWORD (WINAPI *pGetAdaptersInfo)(PIP_ADAPTER_INFO,PULONG);
 static DWORD (WINAPI *pGetIpForwardTable)(PMIB_IPFORWARDTABLE,PULONG,BOOL);
@@ -1310,7 +1314,11 @@ static void Init (void)
 
     ntdll = LoadLibraryA("ntdll.dll");
     if (ntdll)
+    {
         pNtClose = (void *)GetProcAddress(ntdll, "NtClose");
+        pNtSetInformationFile = (void *)GetProcAddress(ntdll, "NtSetInformationFile");
+        pNtQueryInformationFile = (void *)GetProcAddress(ntdll, "NtQueryInformationFile");
+    }
 
     ok ( WSAStartup ( ver, &data ) == 0, "WSAStartup failed\n" );
     tls = TlsAlloc();
@@ -9626,10 +9634,13 @@ end:
 
 static void test_completion_port(void)
 {
+    FILE_IO_COMPLETION_NOTIFICATION_INFORMATION io_info;
     HANDLE previous_port, io_port;
     WSAOVERLAPPED ov, *olp;
     SOCKET src, dest, dup, connector = INVALID_SOCKET;
     WSAPROTOCOL_INFOA info;
+    IO_STATUS_BLOCK io;
+    NTSTATUS status;
     char buf[1024];
     WSABUF bufs;
     DWORD num_bytes, flags;
@@ -10241,6 +10252,16 @@ static void test_completion_port(void)
     io_port = CreateIoCompletionPort((HANDLE)dest, previous_port, 236, 0);
     ok(io_port != NULL, "failed to create completion port %u\n", GetLastError());
 
+    io_info.Flags = FILE_SKIP_COMPLETION_PORT_ON_SUCCESS;
+    status = pNtSetInformationFile((HANDLE)src, &io, &io_info, sizeof(io_info), FileIoCompletionNotificationInformation);
+    ok(status == STATUS_SUCCESS || broken(status == STATUS_INVALID_INFO_CLASS) /* XP */,
+       "expected STATUS_SUCCESS, got %08x\n", status);
+
+    io_info.Flags = FILE_SKIP_COMPLETION_PORT_ON_SUCCESS;
+    status = pNtSetInformationFile((HANDLE)dest, &io, &io_info, sizeof(io_info), FileIoCompletionNotificationInformation);
+    ok(status == STATUS_SUCCESS || broken(status == STATUS_INVALID_INFO_CLASS) /* XP */,
+       "expected STATUS_SUCCESS, got %08x\n", status);
+
     bret = pAcceptEx(src, dest, buf, sizeof(buf) - 2*(sizeof(struct sockaddr_in) + 16),
             sizeof(struct sockaddr_in) + 16, sizeof(struct sockaddr_in) + 16,
             &num_bytes, &ov);
@@ -10266,6 +10287,13 @@ static void test_completion_port(void)
     ok(olp == &ov, "Overlapped structure is at %p\n", olp);
     ok(olp && (olp->Internal == (ULONG)STATUS_SUCCESS), "Internal status is %lx\n", olp ? olp->Internal : 0);
 
+    io_info.Flags = 0;
+    status = pNtQueryInformationFile((HANDLE)dest, &io, &io_info, sizeof(io_info), FileIoCompletionNotificationInformation);
+    ok(status == STATUS_SUCCESS || broken(status == STATUS_INVALID_INFO_CLASS) /* XP */,
+       "expected STATUS_SUCCESS, got %08x\n", status);
+    if (status == STATUS_SUCCESS)
+        ok((io_info.Flags & FILE_SKIP_COMPLETION_PORT_ON_SUCCESS) != 0, "got %08x\n", io_info.Flags);
+
     SetLastError(0xdeadbeef);
     key = 0xdeadbeef;
     num_bytes = 0xdeadbeef;
diff -purN '--exclude=*.orig' '--exclude=*.rej' a/server/async.c b/server/async.c
--- a/server/async.c	2018-10-17 15:46:43.000000000 +0300
+++ b/server/async.c	2018-10-28 14:17:41.777785916 +0200
@@ -53,6 +53,7 @@ struct async
     int                  direct_result;   /* a flag if we're passing result directly from request instead of APC  */
     struct completion   *completion;      /* completion associated with fd */
     apc_param_t          comp_key;        /* completion key associated with fd */
+    unsigned int         comp_flags;      /* completion flags */
 };
 
 static void async_dump( struct object *obj, int verbose );
@@ -240,6 +241,7 @@ struct async *create_async( struct fd *f
     async->wait_handle   = 0;
     async->direct_result = 0;
     async->completion    = fd_get_completion( fd, &async->comp_key );
+    async->comp_flags    = 0;
 
     if (iosb) async->iosb = (struct iosb *)grab_object( iosb );
     else async->iosb = NULL;
@@ -259,7 +261,7 @@ struct async *create_async( struct fd *f
 
 /* create an async associated with iosb for async-based requests
  * returned async must be passed to async_handoff */
-struct async *create_request_async( struct fd *fd, const async_data_t *data )
+struct async *create_request_async( struct fd *fd, unsigned int comp_flags, const async_data_t *data )
 {
     struct async *async;
     struct iosb *iosb;
@@ -277,6 +279,7 @@ struct async *create_request_async( stru
             return NULL;
         }
         async->direct_result = 1;
+        async->comp_flags = comp_flags;
     }
     return async;
 }
@@ -378,8 +381,11 @@ void async_set_result( struct object *ob
             data.user.args[2] = 0;
             thread_queue_apc( NULL, async->thread, NULL, &data );
         }
-        else if (async->data.apc_context)
+        else if (async->data.apc_context && (!async->direct_result ||
+                 !(async->comp_flags & COMPLETION_SKIP_ON_SUCCESS)))
+        {
             add_async_completion( async, async->data.apc_context, status, total );
+        }
 
         if (async->event) set_event( async->event );
         else if (async->fd) set_fd_signaled( async->fd, 1 );
diff -purN '--exclude=*.orig' '--exclude=*.rej' a/server/fd.c b/server/fd.c
--- a/server/fd.c	2018-10-17 15:46:43.000000000 +0300
+++ b/server/fd.c	2018-10-28 14:17:48.928784572 +0200
@@ -195,6 +195,7 @@ struct fd
     struct async_queue   wait_q;      /* other async waiters of this fd */
     struct completion   *completion;  /* completion object attached to this fd */
     apc_param_t          comp_key;    /* completion key to set in completion events */
+    unsigned int         comp_flags;  /* completion flags */
     int                  esync_fd;    /* esync file descriptor */
 };
 
@@ -1613,6 +1614,7 @@ static struct fd *alloc_fd_object(void)
     fd->fs_locks   = 1;
     fd->poll_index = -1;
     fd->completion = NULL;
+    fd->comp_flags = 0;
     fd->esync_fd   = -1;
     init_async_queue( &fd->read_q );
     init_async_queue( &fd->write_q );
@@ -1649,6 +1651,7 @@ struct fd *alloc_pseudo_fd( const struct
     fd->fs_locks   = 0;
     fd->poll_index = -1;
     fd->completion = NULL;
+    fd->comp_flags = 0;
     fd->no_fd_status = STATUS_BAD_DEVICE_TYPE;
     fd->esync_fd   = -1;
     init_async_queue( &fd->read_q );
@@ -2392,6 +2395,7 @@ void fd_copy_completion( struct fd *src,
 {
     assert( !dst->completion );
     dst->completion = fd_get_completion( src, &dst->comp_key );
+    dst->comp_flags = src->comp_flags;
 }
 
 /* flush a file buffers */
@@ -2402,7 +2406,7 @@ DECL_HANDLER(flush)
 
     if (!fd) return;
 
-    if ((async = create_request_async( fd, &req->async )))
+    if ((async = create_request_async( fd, fd->comp_flags, &req->async )))
     {
         reply->event = async_handoff( async, fd->fd_ops->flush( fd, async ), NULL );
         release_object( async );
@@ -2501,7 +2505,7 @@ DECL_HANDLER(read)
 
     if (!fd) return;
 
-    if ((async = create_request_async( fd, &req->async )))
+    if ((async = create_request_async( fd, fd->comp_flags, &req->async )))
     {
         reply->wait    = async_handoff( async, fd->fd_ops->read( fd, async, req->pos ), NULL );
         reply->options = fd->options;
@@ -2518,7 +2522,7 @@ DECL_HANDLER(write)
 
     if (!fd) return;
 
-    if ((async = create_request_async( fd, &req->async )))
+    if ((async = create_request_async( fd, fd->comp_flags, &req->async )))
     {
         reply->wait    = async_handoff( async, fd->fd_ops->write( fd, async, req->pos ), &reply->size );
         reply->options = fd->options;
@@ -2536,7 +2540,7 @@ DECL_HANDLER(ioctl)
 
     if (!fd) return;
 
-    if ((async = create_request_async( fd, &req->async )))
+    if ((async = create_request_async( fd, fd->comp_flags, &req->async )))
     {
         reply->wait    = async_handoff( async, fd->fd_ops->ioctl( fd, req->code, async ), NULL );
         reply->options = fd->options;
@@ -2599,11 +2603,39 @@ DECL_HANDLER(add_fd_completion)
     struct fd *fd = get_handle_fd_obj( current->process, req->handle, 0 );
     if (fd)
     {
-        if (fd->completion)
+        if (fd->completion && (!(fd->comp_flags & COMPLETION_SKIP_ON_SUCCESS) || req->status || req->force))
             add_completion( fd->completion, fd->comp_key, req->cvalue, req->status, req->information );
         release_object( fd );
     }
 }
+
+/* set fd completion information */
+DECL_HANDLER(set_fd_compl_info)
+{
+    struct fd *fd = get_handle_fd_obj( current->process, req->handle, 0 );
+    if (fd)
+    {
+        if (!(fd->options & (FILE_SYNCHRONOUS_IO_ALERT | FILE_SYNCHRONOUS_IO_NONALERT)))
+        {
+            /* removing COMPLETION_SKIP_ON_SUCCESS is not allowed */
+            fd->comp_flags |= req->flags;
+        }
+        else
+            set_error( STATUS_INVALID_PARAMETER );
+        release_object( fd );
+    }
+}
+
+/* get fd completion information */
+DECL_HANDLER(get_fd_compl_info)
+{
+    struct fd *fd = get_handle_fd_obj( current->process, req->handle, 0 );
+    if (fd)
+    {
+        reply->flags = fd->comp_flags;
+        release_object( fd );
+    }
+}
 
 /* set fd disposition information */
 DECL_HANDLER(set_fd_disp_info)
diff -purN '--exclude=*.orig' '--exclude=*.rej' a/server/file.h b/server/file.h
--- a/server/file.h	2018-10-17 15:46:43.000000000 +0300
+++ b/server/file.h	2018-10-28 14:17:41.778785916 +0200
@@ -185,7 +185,7 @@ extern struct object *create_serial( str
 /* async I/O functions */
 extern void free_async_queue( struct async_queue *queue );
 extern struct async *create_async( struct fd *fd, struct thread *thread, const async_data_t *data, struct iosb *iosb );
-extern struct async *create_request_async( struct fd *fd, const async_data_t *data );
+extern struct async *create_request_async( struct fd *fd, unsigned int comp_flags, const async_data_t *data );
 extern obj_handle_t async_handoff( struct async *async, int success, data_size_t *result );
 extern void queue_async( struct async_queue *queue, struct async *async );
 extern void async_set_timeout( struct async *async, timeout_t timeout, unsigned int status );
diff -purN '--exclude=*.orig' '--exclude=*.rej' a/server/protocol.def b/server/protocol.def
--- a/server/protocol.def	2018-10-17 15:46:43.000000000 +0300
+++ b/server/protocol.def	2018-10-28 14:17:48.929784572 +0200
@@ -3704,6 +3704,23 @@ struct handle_info
     apc_param_t    cvalue;        /* completion value */
     apc_param_t    information;   /* IO_STATUS_BLOCK Information */
     unsigned int   status;        /* completion status */
+    int            force;         /* don't check if skip-on-success is set */
+@END
+
+
+/* set fd completion information */
+@REQ(set_fd_compl_info)
+    obj_handle_t handle;          /* handle to a file or directory */
+    int          flags;           /* completion flags (see below) */
+@END
+#define COMPLETION_SKIP_ON_SUCCESS 0x01
+
+
+/* get fd completion information */
+@REQ(get_fd_compl_info)
+    obj_handle_t handle;          /* handle to a file or directory */
+@REPLY
+    int          flags;           /* completion flags (see below) */
 @END
 
 
